<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pembelajaran Bilangan Bulat âœ¨</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap");
    </style>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">AddSub Integer</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          style="background: white; border-radius: 15px"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a
                class="nav-link active"
                href="index.html"
                data-transition="fade"
                >âž• Penjumlahan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="pengurangan.html" data-transition="fade"
                >âž– Pengurangan</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="Interaktif1.html"
                >ðŸ§© Interaktif Penjumlahan dan Pengurangan</a
               >
              </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container my-5 content">
      <div class="text-center">
        <h1>Penjumlahan Bilangan Bulat</h1>
      </div>

      <div class="input-group justify-content-center mb-4">
        <input
          type="number"
          id="num1"
          placeholder="Angka Pertama"
          class="form-control w-auto me-2"
          oninput="startAnimation()"
          style="max-width: 200px"
        />
        <div class="operator-box">+</div>
        <input
          type="number"
          id="num2"
          placeholder="Angka Kedua"
          class="form-control w-auto me-2"
          oninput="startAnimation()"
          style="max-width: 200px"
        />
        <button
          class="btn btn-info rounded-circle d-flex align-items-center justify-content-center"
          onclick="showInstructions()"
          title="Petunjuk"
          style="width: 50px; height: 50px"
        >
          ðŸ’¡
        </button>
      </div>

      <div class="card canvas-card mb-4">
        <div class="card-body p-0">
          <canvas id="garis" width="700" height="280"></canvas>
        </div>
      </div>

      <div
        id="hasil"
        class="alert alert-success text-center result-alert"
        role="alert"
        style="display: none"
      ></div>
    </div>

    <div id="instructionModal" class="modal fade" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Instruksi Penggunaan</h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
            ></button>
          </div>
          <div class="modal-body">
            <p>
              <b>ðŸŒŸ Angka Pertama</b><br />
              Menentukan titik awal pada garis bilangan.<br />
              â€¢ Jika positif (+), mobil bergerak ke kanan dari 0<br />
              â€¢ Jika negatif (-), mobil bergerak ke kiri dari 0<br /><br />

              <b>ðŸ’œ Angka Kedua</b><br />
              Menentukan langkah berikutnya:<br />
              â€¢ Jika positif (+), mobil menghadap kanan dan bergerak ke kanan<br />
              â€¢ Jika negatif (-), mobil menghadap kiri dan bergerak ke kiri<br /><br />

              <b>ðŸš— Lampu Mobil</b><br />
              â€¢ ðŸŸ¡ Kuning = Lampu depan (headlight)<br />
              â€¢ ðŸ”´ Merah = Lampu belakang (taillight)<br />
              Perhatikan posisi lampu untuk mengetahui arah hadap mobil!<br /><br />

              <b>Note</b><br />
              Misalkan a adalah bilangan bulat, maka a + (âˆ’b) = a âˆ’ b
            </p>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      const canvas = document.getElementById("garis");
      const ctx = canvas.getContext("2d");
      const hasilDiv = document.getElementById("hasil");
      let animationFrameId;
      const padding = 60;

      // Create tooltip element
      const tooltip = document.createElement("div");
      tooltip.className = "tooltip";
      tooltip.style.cssText =
        "position: absolute; background: linear-gradient(135deg, #9F7AEA, #805AD5); color: white; padding: 8px 15px; border-radius: 15px; font-size: 14px; font-weight: 600; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 9999; box-shadow: 0 4px 12px rgba(128, 90, 213, 0.4);";
      document.body.appendChild(tooltip);

      // Responsive canvas
      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.offsetWidth - 40;
        canvas.height = 280;
        if (
          document.getElementById("num1").value ||
          document.getElementById("num2").value
        ) {
          startAnimation();
        }
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function drawNumberLine(minVal, maxVal, num1, num2, result) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const canvasWidth = canvas.width - 2 * padding;
        const ticks = [];

        // Always include 0, num1, and result
        ticks.push(0);
        if (num1 !== 0) ticks.push(num1);
        if (result !== 0 && result !== num1) ticks.push(result);

        // Add detailed ticks around result (kerucut/focused area)
        const resultDetailRange = 3;
        for (
          let i = result - resultDetailRange;
          i <= result + resultDetailRange;
          i++
        ) {
          if (i !== num1) {
            // Don't add ticks between num1 and result
            ticks.push(i);
          }
        }

        // Add some intermediate points between 0 and num1 (if distance is large)
        const distance0ToNum1 = Math.abs(num1);
        if (distance0ToNum1 > 10) {
          const step = Math.max(1, Math.floor(distance0ToNum1 / 5));
          const start = Math.min(0, num1);
          const end = Math.max(0, num1);
          for (let i = start; i <= end; i += step) {
            if (
              i !== 0 &&
              i !== num1 &&
              Math.abs(i - result) > resultDetailRange
            ) {
              ticks.push(i);
            }
          }
        } else {
          // For smaller distances, add every number between 0 and num1
          const start = Math.min(0, num1);
          const end = Math.max(0, num1);
          for (let i = start; i <= end; i++) {
            if (Math.abs(i - result) > resultDetailRange) {
              ticks.push(i);
            }
          }
        }

        // Add boundary ticks for context
        if (result > 0) {
          ticks.push(result + resultDetailRange + 1);
        } else {
          ticks.push(result - resultDetailRange - 1);
        }

        const uniqueTicks = [...new Set(ticks)].sort((a, b) => a - b);
        const tickSpacing = canvasWidth / (uniqueTicks.length - 1);

        const tickPositions = new Map();
        uniqueTicks.forEach((tick, index) => {
          const x = padding + index * tickSpacing;
          tickPositions.set(tick, x);
        });

        // Draw main gradient line
        const gradient = ctx.createLinearGradient(
          padding,
          100,
          canvas.width - padding,
          100
        );
        gradient.addColorStop(0, "#B794F4");
        gradient.addColorStop(0.5, "#9F7AEA");
        gradient.addColorStop(1, "#B794F4");

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(padding, 100);
        ctx.lineTo(canvas.width - padding, 100);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Draw ticks and numbers
        ctx.font = "bold 14px Quicksand";
        ctx.fillStyle = "#9F7AEA";
        ctx.textAlign = "center";

        uniqueTicks.forEach((tick, index) => {
          const x = padding + index * tickSpacing;
          if (x >= padding - 10 && x <= canvas.width - padding + 10) {
            // Special styling for zero
            if (tick === 0) {
              ctx.strokeStyle = "#9F7AEA";
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(x, 88);
              ctx.lineTo(x, 112);
              ctx.stroke();
              ctx.fillStyle = "#6B46C1";
              ctx.font = "bold 18px Quicksand";
              ctx.fillText("0", x, 135);
              ctx.font = "bold 14px Quicksand";
            } else {
              ctx.strokeStyle = "#D4B5F0";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(x, 93);
              ctx.lineTo(x, 107);
              ctx.stroke();
              ctx.fillStyle = "#9F7AEA";
              ctx.fillText(tick, x, 135);
            }
          }
        });

        // Draw arrow heads at ends
        drawArrowhead(canvas.width - padding, 100, "right", "#9F7AEA");
        drawArrowhead(padding, 100, "left", "#9F7AEA");

        return { tickPositions, uniqueTicks };
      }

      function drawArrowhead(x, y, direction, color) {
        ctx.fillStyle = color;
        ctx.shadowColor = "rgba(159, 122, 234, 0.3)";
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        if (direction === "right") {
          ctx.lineTo(x - 10, y - 8);
          ctx.lineTo(x - 10, y + 8);
        } else {
          ctx.lineTo(x + 10, y - 8);
          ctx.lineTo(x + 10, y + 8);
        }
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      function drawCar(x, y, direction, color, isReverse = false, isSilhouette = false) {
        ctx.save();
        ctx.translate(x, y);
        
        // Flip car based on direction
        if (direction === "left") {
          ctx.scale(-1, 1);
        }
        
        // Set global alpha for silhouette
        if (isSilhouette) {
          ctx.globalAlpha = 0.95;
        }
        
        // Car body shadow (reduced for silhouette)
        if (!isSilhouette) {
          ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
          ctx.shadowBlur = 8;
          ctx.shadowOffsetY = 3;
        }
        
        // Car body (main)
        ctx.fillStyle = isSilhouette ? 'rgba(107, 70, 193, 0.5)' : color;
        ctx.beginPath();
        ctx.roundRect(-25, -12, 50, 20, 5);
        ctx.fill();
        
        // Car roof
        ctx.beginPath();
        ctx.roundRect(-15, -22, 28, 12, 4);
        ctx.fill();
        
        // Reset shadow for details
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        
        // Windows
        ctx.fillStyle = isSilhouette ? "rgba(135, 206, 250, 0.4)" : "rgba(135, 206, 250, 0.9)";
        ctx.beginPath();
        ctx.roundRect(-12, -20, 11, 8, 2);
        ctx.fill();
        ctx.beginPath();
        ctx.roundRect(1, -20, 11, 8, 2);
        ctx.fill();
        
        // Headlight and Taillight
        if (!isSilhouette) {
          // Headlight yellow at front (x=22), taillight red at back (x=-22)
          ctx.fillStyle = "#FFD700";
          ctx.beginPath();
          ctx.ellipse(22, -2, 4, 3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = "#FF4444";
          ctx.beginPath();
          ctx.ellipse(-22, -2, 3, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Silhouette lights (faded)
          ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
          ctx.beginPath();
          ctx.ellipse(22, -2, 4, 3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = "rgba(255, 68, 68, 0.3)";
          ctx.beginPath();
          ctx.ellipse(-22, -2, 3, 3, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Wheels
        ctx.fillStyle = isSilhouette ? "rgba(51, 51, 51, 0.4)" : "#333";
        ctx.beginPath();
        ctx.arc(-15, 10, 7, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(15, 10, 7, 0, Math.PI * 2);
        ctx.fill();
        
        // Wheel caps
        ctx.fillStyle = isSilhouette ? "rgba(136, 136, 136, 0.4)" : "#888";
        ctx.beginPath();
        ctx.arc(-15, 10, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(15, 10, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }

      function drawTrail(startX, endX, y, color) {
        const gradient = ctx.createLinearGradient(startX, y, endX, y);
        if (startX < endX) {
          gradient.addColorStop(0, "rgba(255,255,255,0)");
          gradient.addColorStop(0.3, color + "40");
          gradient.addColorStop(1, color + "90");
        } else {
          gradient.addColorStop(0, color + "90");
          gradient.addColorStop(0.7, color + "40");
          gradient.addColorStop(1, "rgba(255,255,255,0)");
        }
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(Math.min(startX, endX), y - 4, Math.abs(endX - startX), 8, 4);
        ctx.fill();
        
        // Tire marks
        ctx.strokeStyle = color + "60";
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 6]);
        ctx.beginPath();
        ctx.moveTo(startX, y + 3);
        ctx.lineTo(endX, y + 3);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(startX, y - 3);
        ctx.lineTo(endX, y - 3);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawDustParticles(x, y, direction, progress) {
        const numParticles = 5;
        for (let i = 0; i < numParticles; i++) {
          const offsetX = direction === "right" ? -20 - Math.random() * 30 : 20 + Math.random() * 30;
          const offsetY = (Math.random() - 0.5) * 20;
          const size = 2 + Math.random() * 4;
          const alpha = 0.3 + Math.random() * 0.3;
          
          ctx.fillStyle = `rgba(200, 180, 160, ${alpha * (1 - (progress % 0.3) / 0.3)})`;
          ctx.beginPath();
          ctx.arc(x + offsetX, y + offsetY, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawResultMarker(x, y, result) {
        ctx.shadowColor = "rgba(107, 70, 193, 0.5)";
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = "#6B46C1";
        ctx.fill();
        ctx.shadowBlur = 0;

        // Inner highlight
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.beginPath();
        ctx.arc(x - 3, y - 3, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      let resultX, resultY, resultValue;
      let label2Info = { x: 0, y: 0, width: 0, num2: 0, visible: false };

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Check hover on result marker
        if (resultX && Math.hypot(mouseX - resultX, mouseY - resultY) < 15) {
          tooltip.style.left = `${e.clientX + 10}px`;
          tooltip.style.top = `${e.clientY - 10}px`;
          tooltip.textContent = `Hasil: ${resultValue}`;
          tooltip.style.opacity = "1";
        }
        // Check hover on second label (num2 operation)
        else if (label2Info.visible && 
                 mouseX >= label2Info.x - label2Info.width/2 - 15 && 
                 mouseX <= label2Info.x + label2Info.width/2 + 15 &&
                 mouseY >= label2Info.y - 20 && 
                 mouseY <= label2Info.y + 20) {
          tooltip.style.left = `${e.clientX + 10}px`;
          tooltip.style.top = `${e.clientY - 10}px`;
          if (label2Info.num2 < 0) {
            tooltip.textContent = `+(${label2Info.num2}) = ${label2Info.num2} âœ¨`;
          } else {
            tooltip.textContent = `+${label2Info.num2} ðŸ’«`;
          }
          tooltip.style.opacity = "1";
        } else {
          tooltip.style.opacity = "0";
        }
      });

      canvas.addEventListener("mouseleave", () => {
        tooltip.style.opacity = "0";
      });

      function startAnimation() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);

        const num1 = parseInt(document.getElementById("num1").value) || 0;
        const num2 = parseInt(document.getElementById("num2").value) || 0;
        const hasil = num1 + num2;

        resultValue = hasil;

        const values = [0, num1, hasil];
        const minVal = Math.min(...values) - 3;
        const maxVal = Math.max(...values) + 3;

        const { tickPositions, uniqueTicks } = drawNumberLine(
          minVal,
          maxVal,
          num1,
          num2,
          hasil
        );

        const startX = tickPositions.get(0) || padding;
        const targetMidX =
          tickPositions.get(num1) ||
          (num1 >= 0 ? padding : canvas.width - padding);
        let targetEndX = tickPositions.get(hasil);

        if (targetEndX === undefined) {
          const sortedTicks = [...uniqueTicks].sort((a, b) => a - b);
          const index = sortedTicks.findIndex((tick) => tick >= hasil);
          const prevTick = sortedTicks[index - 1] || sortedTicks[0];
          const nextTick =
            sortedTicks[index] || sortedTicks[sortedTicks.length - 1];
          const prevX = tickPositions.get(prevTick) || padding;
          const nextX =
            tickPositions.get(nextTick) ||
            (nextTick >= 0 ? canvas.width - padding : padding);
          const ratio = (hasil - prevTick) / (nextTick - prevTick) || 1;
          targetEndX = prevX + (nextX - prevX) * ratio;
        }

        let currentX = startX;
        let midXReached = false;
        const animationDuration = 1200;
        let startTime;

        function animate(timestamp) {
          if (!startTime) startTime = timestamp;
          const progress = (timestamp - startTime) / animationDuration;

          drawNumberLine(minVal, maxVal, num1, num2, hasil);

          if (!midXReached) {
            currentX = startX + (targetMidX - startX) * Math.min(progress, 1);

            // First trail (num1) - purple
            const trailColor1 = '#B794F4';
            drawTrail(startX, currentX, 70, trailColor1);
            
            // Draw dust particles
            if (progress < 1) {
              const carDirection1 = num1 >= 0 ? "right" : "left";
              drawDustParticles(currentX, 70, carDirection1, progress);
            }
            
            // Draw single car
            const num1Direction = num1 >= 0 ? "right" : "left";
            drawCar(currentX, 65, num1Direction, '#6B46C1');

            // Label for num1
            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = '#B794F4';
            ctx.textAlign = "center";
            const labelX1 = (startX + currentX) / 2;
            const labelY1 = 70 - 35;

            // Background bubble
            const text1 = num1.toString();
            const textWidth1 = ctx.measureText(text1).width;
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#B794F4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(labelX1 - textWidth1/2 - 10, labelY1 - 18, textWidth1 + 20, 28, 14);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#B794F4';
            ctx.fillText(text1, labelX1, labelY1);

            if (progress >= 1) {
              midXReached = true;
              startTime = timestamp;
              currentX = targetMidX;
            }
          } else {
            const secondProgress = (timestamp - startTime) / animationDuration;
            currentX = targetMidX + (targetEndX - targetMidX) * Math.min(secondProgress, 1);

            // First trail stays - purple
            const trailColor1 = '#B794F4';
            drawTrail(startX, targetMidX, 70, trailColor1);
            
            // Draw silhouette/ghost car at end of first journey (num1 position)
            const num1Direction = num1 >= 0 ? "right" : "left";
            drawCar(targetMidX, 65, num1Direction, 'rgba(107, 70, 193, 0.3)', false, true);

            // Label for num1
            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = '#B794F4';
            ctx.textAlign = "center";
            const labelX1 = (startX + targetMidX) / 2;
            const labelY1 = 70 - 35;

            const text1 = num1.toString();
            const textWidth1 = ctx.measureText(text1).width;
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#B794F4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(labelX1 - textWidth1/2 - 10, labelY1 - 18, textWidth1 + 20, 28, 14);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#B794F4';
            ctx.fillText(text1, labelX1, labelY1);

            // Second trail - green or red based on direction
            const trailColor2 = num2 >= 0 ? '#10B981' : '#EF4444';
            
            // Draw trail for second movement
            drawTrail(targetMidX, currentX, 70, trailColor2);
            
            // Draw dust particles
            // Actual movement direction (where the car physically goes)
            const actualMovementDirection = num2 >= 0 ? "right" : "left";
            
            if (secondProgress < 1) {
              drawDustParticles(currentX, 70, actualMovementDirection, secondProgress);
            }
            
            // Draw single car at current position
            // When num2 is negative: car faces LEFT and moves LEFT (same as num1 negative behavior)
            // When num2 is positive: car faces RIGHT and moves RIGHT
            const carFacingDirection = num2 >= 0 ? "right" : "left";
            drawCar(currentX, 65, carFacingDirection, '#6B46C1');

            // Label for second movement (simple label, detailed info on hover)
            ctx.font = "bold 16px Quicksand";
            ctx.fillStyle = trailColor2;
            ctx.textAlign = "center";
            const labelX2 = (targetMidX + currentX) / 2;
            const labelY2 = 70 + 45;

            // Simple label showing just the number (effective movement)
            const text2 = num2 >= 0 ? `+${num2}` : `${num2}`;
            const textWidth2 = ctx.measureText(text2).width;
            ctx.fillStyle = 'white';
            ctx.strokeStyle = trailColor2;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(labelX2 - textWidth2/2 - 10, labelY2 - 18, textWidth2 + 20, 28, 14);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = trailColor2;
            ctx.fillText(text2, labelX2, labelY2);
            
            // Store label info for hover tooltip
            label2Info = { x: labelX2, y: labelY2, width: textWidth2 + 20, num2: num2, visible: true };

            // Result display with detailed explanation
            hasilDiv.style.display = "block";
            if (num2 < 0) {
              hasilDiv.innerHTML = `${num1} + (${num2}) = ${num1} âˆ’ ${-num2} = <b>${hasil}</b>`;
            } else {
              hasilDiv.innerHTML = `${num1} + ${num2} = <b>${hasil}</b>`;
            }
            hasilDiv.classList.add("updated");
            setTimeout(() => hasilDiv.classList.remove("updated"), 600);

            if (secondProgress >= 1) {
              resultX = targetEndX;
              resultY = 100;
              drawResultMarker(targetEndX, 100, hasil);
              return;
            }
          }

          animationFrameId = requestAnimationFrame(animate);
        }

        animationFrameId = requestAnimationFrame(animate);
      }

      function showInstructions() {
        const modal = new bootstrap.Modal(
          document.getElementById("instructionModal")
        );
        modal.show();
      }

      function switchPage(page) {
        alert(`Fitur ${page} akan segera hadir! ðŸŒŸâœ¨`);
      }
    </script>
  </body>
</html>
